# **Design Pattern**

> *Design Patterns ou Padrões de Projetos são soluções generalistas para problemas recorrentes durante o desenvolvimento de um software. Não se trata de um framework ou um código pronto, mas de uma definição de alto nível de como um problema comum pode ser solucionado.*

Esses conceitos ficaram realmente conhecidos em 1994, quando os engenheiros de software Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides escreveram o livro **“Design Patterns: Elements of Reusable Object-Oriented Software”** com o objetivo de catalogar problemas comuns aos projetos de desenvolvimento de software e as formas de resolver esses problemas. Os autores catalogaram 23 padrões que utilizaram ao longo de suas carreiras. 

### Quais os benefícios de utilizar Design Pattern?

Design Patterns são modelos que já foram utilizados e testados anteriormente, portanto podem representar um bom **ganho de produtividade** para os desenvolvedores. Seu uso também contribui para a **organização e manutenção** de projetos, já que esses padrões se baseiam em baixo acoplamento entre as classes e padronização do código. Além disso, com a padronização dos termos, as **discussões técnicas** são **facilitadas**. É mais fácil falar o nome de um Design Pattern em vez de ter que explicar todo o seu comportamento.

Os autores do livro **“Design Patterns: Elements of Reusable Object-Oriented Software”** agruparam os Design Patterns em três tipos diferentes: Creational (Criação), Structural (Estrutura), Behavioral (Comportamental). Assim como podemos ver na tabela abaixo. 

> **Observação:** Nessa tabela também foram acrescentadas novos Design Patterns. 

| Creational Patterns | Structural Patterns |   Behavioral Patterns   |
| :-----------------: | :-----------------: | :---------------------: |
|  Abstract Factory   |       Adapter       | Chain of Responsibility |
|       Builder       |       Bridge        |         Command         |
|   Factory Method    |      Composite      |       Interpreter       |
|     Object Pool     |      Decorator      |        Iterator         |
|      Prototype      |       Facade        |        Mediator         |
|      Singleton      |      Flyweight      |       Null Object       |
|                     | Private Class Data  |        Observer         |
|                     |        Proxy        |          State          |
|                     |                     |        Strategy         |
|                     |                     |     Template Method     |
|                     |                     |         Visitor         |

## Creational Patterns

### Abstract Factory

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Builder

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Factory Method

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Object Pool

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Prototype

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Singleton

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

## Structural Patterns

### Adapter

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Bridge

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Composite

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Decorator

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Facade

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Flyweight

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Private Class Data

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Proxy

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

## Behavioral Patterns

### Chain of Responsibility

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Command

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Interpreter

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Iterator

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Mediator

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Null Object

**Definição**

> *O padrão Null Object propõe a criação de uma classe para representar objetos nulos em uma aplicação.*

**Utilização**

Essa classe deve estender a classe original e implementar seus métodos de forma a executar o comportamento esperado da aplicação quando um valor nulo for recebido. Dessa forma, em vez de se retornar um valor nulo, retorna-se uma instância dessa nova classe.

**Veja um exemplo:**

##### Diagrama de Classe

| ![](src/uml/NullObject.png) |
| :--------------------------: |

##### Classe Null Object

```kotlin
class NullObject {

    abstract class ClienteAbstrato{

        abstract fun isNulo():Boolean
        abstract fun getNome():String
    }
    class ClienteReal(private var nome:String):ClienteAbstrato(){

        override fun isNulo(): Boolean = false
        override fun getNome(): String = nome

    }
    class ClienteNulo:ClienteAbstrato(){

        override fun isNulo(): Boolean = true
        override fun getNome(): String = "Não existe esse nome na lista"

    }
    class ClienteFactory{

        companion object Fabrica{

            val listaNomes = listOf("Lucas", "João", "Maria")

            fun getCliente(nome:String):ClienteAbstrato{

                listaNomes.forEach { nomes->

                    if (nomes == nome) {
                        return ClienteReal(nome)
                    }

                }

                return ClienteNulo()

            }
        }
    }

}
```

#### **Pontos Positivos**

- **Leitura mais eficiente:** quando usamos esse padrão em nosso projeto, isso torna o nosso *código mais legível e organizado*. Além disso, ela *facilita a leitura e entendimento por parte de outros programadores*.

- **Melhor tratamento de valores nulos no projeto:** uma consequência interessante da aplicação desse padrão é que ele *remove a necessidade de ter lógica especial para verificar cada valor nulo*. 
- **Uso de herança:** esse padrão demonstra bem as *características da herança*, pois ele permite que o código cliente possa ser utilizado, mesmo para o caso de um objeto nulo.

> **Herança:** é um mecanismo que permite que características comuns a diversas classes sejam fatoradas em uma classe base, ou superclasse. Esse importante conceito possibilita que as classes compartilhem seus atributos, métodos e outros membros da classe entre si. Para a ligação entre as classes, a herança adota um relacionamento esquematizado hierarquicamente. Na Herança temos dois tipos principais de classe:
>
> - **Classe Base, Classe Pai ou Superclasse**: é a classe que concede as características a uma outra classe.
> - **Classe Derivada, Classe Filho ou Subclasse**: é a classe que herda as características da classe base (também chamada de classe pai ou superclasse).

> **Dica:** Uma bom teste para verificar se o uso de herança é adequado em uma determinada situação é ver se faz sentido substituir a implementação por uma de suas subclasses em todos os contextos. Isso respeita o *Princípio da Substituição de Liskov*  (Para mais detalhes, veja o projeto que eu criei falando mais sobre a importância do SOLID clicando aqui).

#### **Pontos Negativos**

- **O tratamento de valores nulos não fica explícito:** isso pode gerar uma certa confusão na hora de ler e dar manutenção nesse código.
- **Casos específicos:** caso o padrão não seja aplicado da maneira a trabalhar com Interface (estrutura de linguagem) e outros programadores do projeto não estejam ciente da aplicação dele no algoritmo, esses outros programadores podem acabar colocando verificações para valores **nulos** quando esses nunca ocorreram, inflando o código ainda mais.

#### Regras de Ouro

- **A classe do padrão** *Null Object* **geralmente é implementada como um padrão** *Singleton*. Como um ***objeto nulo geralmente não tem nenhum estado, seu estado não pode ser alterado***, portanto, várias instâncias são idênticas. Em vez de usar várias instâncias idênticas, ***o sistema pode apenas usar uma única instância repetidamente***.
- Se alguns clientes **esperam que o objeto nulo não faça nada de uma maneira e de outra**, várias ***classes do padrão Null Object serão necessárias***. Se o **comportamento da classe não faz nada**, então ***a classe deve ser customizada em tempo de execução***. A classe do padrão Null Object exigirá variáveis conectadas para que o cliente possa especificar que o objeto nulo não deve fazer nada. 
- **Um objeto nulo não se transforma em um objeto real**. Se o objeto decidir parar de fornecer um comportamento que não faz nada e *começar a fornecer um comportamento real, então ele não é um objeto nulo*. **Se um objeto que não faz nada** (ou seja, um objeto nulo), **sofre mudanças para um objeto real**, então ele *deve ser implementado com o padrão State ou talvez o padrão Proxy*. Nesse caso, um Estado Nulo (ou **State Null**) pode ser usado ou o padrão Proxy pode conter um objeto nulo.
- **O uso de um objeto nulo pode ser semelhante ao uso do padrão *Proxy***, mas *os dois padrões têm finalidades diferentes*. Um objeto proxy acessa o um objeto real de forma indireta controlando assim o acesso. Um colaborador nulo não oculta um objeto real e controla o acesso a ele, ele substitui o objeto real. Um objeto proxy pode eventualmente sofrer mudanças para começar a agir como um objeto real. Um objeto nulo não sofrerá mudanças para começar a fornecer um comportamento real, ele sempre fornecerá um comportamento nulo, ou seja um comportamento que não faz nada.
- **Um objeto nulo pode ser um caso especial do padrão *Strategy***. O padrão *Strategy* especifica várias classes com diferentes abordagens para realizar uma tarefa. Por exemplo: s*e uma das classes Strategy não faz nada de forma consistente* (essa classe pode ser chamada de ConcreteStrategy, por exemplo), *essa classe é um classe Null Object*.
- **Um objeto nulo pode ser um caso especial do padrão** *State*. Normalmente, cada classe de estado (*State*) tem alguns métodos que não fazem nada, ou seja, métodos nulos. Isso acontece porque eles não são apropriados para aquele tipo de estado. Na verdade, um determinado método é frequentemente implementado para fazer algo útil na maioria dos estados, mas a ação de não fazer nada , ou seja, uma ação nula, acontece em pelo menos um estado. Se uma determinada classe de estado implementa a maioria de seus métodos nulos ou pelo menos fornecer resultados nulos, ele se torna um estado nulo.
- **Um objeto nulo pode ser usado para** permitir que uma classe do padrão *Visitor* *inspecione uma hierarquia com segurança e trate de uma situação nula*.
- *Null Object* **é uma classe colaborativa.** Ela atua como o colaborador para um cliente que precisa de um. *O comportamento nulo*, ou seja, que não faz nada, *não foi projetado para ser misturado a um objeto que precisa de algum comportamento nulo*. Ele é projetado para uma classe que delega a outra todos os comportamentos que podem ou não ter comportamentos nulos.

### Observer

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### State

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Strategy

**Definição**

> *Define uma família de algoritmos, encapsular cada uma delas e as torna intercambiáveis. Esse padrão permite que o algoritmo varie independentemente dos clientes que o utilizam.*

**Utilização**

O Strategy é um padrão que deve ser utilizado quando ***uma classe possuir diversos algoritmos que possam ser utilizados de forma intercambiável***. A solução proposta pelo padrão consiste em delegar a execução do algoritmo para uma instância que compõe a classe principal. Dessa forma, quando a funcionalidade for invocada, no momento da execução do algoritmo, será invocado um método da instância que a compõe.

**Veja um exemplo:**

##### Diagrama de Classe - Strategy

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe Strategy

```kotlin
class Strategy {

    abstract class Felino(private val correrStrategy:CorrerStrategy){

        abstract fun display()
        abstract fun rugir()
        fun perfomarCorrer() = correrStrategy.correr()
        fun getCorrerStrategy(correrStrategy:CorrerStrategy) = correrStrategy.correr()

    }

    class Leao:Felino(CorrerCurtaDistancia()) {

        override fun display() = println("Leão a vista")
        override fun rugir() = println("Urghhhhh!")

    }
    class Leopardo:Felino(CorrerLongaDistancia()){

        override fun display() = println("Leopardo a vista")
        override fun rugir() = println("Arghh!")

    }
    interface CorrerStrategy{
        fun correr()
    }
    class CorrerCurtaDistancia:CorrerStrategy{
        override fun correr() = println("Correr curta distância, porém com o objetivo bem próximo.")
    }
    class CorrerLongaDistancia:CorrerStrategy{
        override fun correr() = println("Correr longa distância, caso necessário.")
    }

}
```

#### **Pontos Positivos**

- **Leitura mais eficiente:** quando usamos esse padrão em nosso projeto, ou em parte dele, isso torna o nosso *código mais legível e organizado*. Além disso, ela facilita a leitura e entendimento por parte de outros programadores.
- **Reutilização de código:**  isso é bem evidente nesse padrão de projeto, sendo que as famílias de algoritmos podem ser *utilizadas por outras classes com diversos contextos diferentes*.
- **Evolução eficiente no seu projeto:** Isso é possível porque o foco aqui é a **composição**. Isso *evita que as classes e subclasses sejam alteradas caso novas funcionalidades sejam adicionadas ou atualizadas*. 

- **O algoritmo pode ser alterado sem a modificação da classe:** a partir dessa estrutura, *novas implementações dele podem ser criadas e introduzidas posteriormente*.
- **A lógica condicional na classe principal é reduzida:** como a escolha do algoritmo está na implementação do objeto que está compondo a classe, isso *elimina a necessidade de ter condicionais para selecionar a lógica a ser executada*. 
- **A implementação pode ser trocada em tempo de execução:** isso faz com que o *comportamento da classe possa ser trocado dinamicamente*. Além disso, o seu projeto se *torna mais dinâmico permitindo assim mais opções de funcionalidades*.

> **Composição (de Objetos):** em ciência da computação, composição de objetos é uma maneira de se combinar objetos simples ou tipos de dados em objetos mais complexos. Ela costuma ser usada como alternativa ao uso de **Herança**.

> **Herança:** é um mecanismo que permite que características comuns a diversas classes sejam fatoradas em uma classe base, ou superclasse. Esse importante conceito possibilita que as classes compartilhem seus atributos, métodos e outros membros da classe entre si. Para a ligação entre as classes, a herança adota um relacionamento esquematizado hierarquicamente. Na Herança temos dois tipos principais de classe:
>
> - **Classe Base**: a classe que concede as características a uma outra classe.
> - **Classe Derivada**: a classe que herda as características da classe base.

#### **Pontos Negativos**

- **Complexidade na criação do objeto:** a instância da dependência *precisa ser criada e configurada*. Caso o atributo seja nulo, *a classe pode apresentar um comportamento inesperado*. 
- **Aumento no número de classes:** há uma para cada algoritmo, criando uma *maior dificuldade em seu gerenciamento*. Isso pode ser muito ruim, se houverem muitas funcionalidades que não podem ser implementadas por classes de uma mesma família de classes Strategy.
- **Complexidade do projeto:** o projeto pode ficar mais *complexo caso uma solução com herança seja mais simples de implementar e manter*.

#### Regras de Ouro

- O padrão *Strategy* é semelhante ao padrão *Template Method*, exceto em sua **granularidade**.
- O padrão *Strategy* é semelhante ao padrão *State*, exceto em sua ***intenção***.
- O padrão Strategy permite que você ***mude o que tem dentro de um objeto***. Já o padrão *Decorator* permite que você ***mude a aparência externa de um objeto***.
- Os padrões *State*, *Strategy*, *Bridge* (e até certo ponto o padrão *Adapter*) têm ***estruturas de solução semelhantes***. Todos eles compartilham elementos do **Handle-Body Idioms**. Eles ***diferem em intenções***, ou seja, eles resolvem problemas diferentes.
- O padrão *Strategy* tem ***duas implementações diferentes***, a primeira é semelhante ao padrão *State*. A diferença está no seu **Binding Times** (O padrão Strategy só tem o seu Binding Times uma vez, enquanto o padrão *State* é mais dinâmico).
- Objetos do padrão *Strategy* costumam usar bem o padrão *Flyweight*.

> **Granularidade (de Dados)**: é a extensão à qual um sistema é dividido em partes pequenas, ou o sistema propriamente dito ou sua descrição ou observação. 

> **Handle-Body Idioms (Idioma de Alça-Corpo):** é usado quando dois objetos são compostos para aparecer como um único objeto. Um objeto, chamado de identificador (ou alça), gerencia a interface, enquanto outro objeto, chamado de corpo, fornece a lógica do aplicativo

> **Binding Times (ou tempo de vinculação) :** é o momento do ciclo de vida do programa em que uma variável é atribuída a seu tipo (inteiro, string, etc). Muitas propriedades de uma linguagem de programação são definidas durante sua criação. Por exemplo, o significado de palavras-chave como ***while*** ou ***for***, ou o tamanho do tipo de dados de uma variável, são propriedades definidas em tempo de design da linguagem. 
>
> **Observação:** Linguagens orientadas a objetos tem o seu tempo de vinculação de forma tardia e atribuem tipos em tempo de execução quando a variável recebe um valor do teclado ou de outra fonte.

### Template Method

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Visitor

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

## Fontes

1. https://www.opus-software.com.br/design-patterns/
2. **Livro:** Design Patterns com Java - Projeto orientado a objetos guiados por padrões - Eduardo Guerra
3. http://www.cs.sjsu.edu/faculty/pearce/patterns/hanbod/hanbod.html
4. https://www.pcmag.com/encyclopedia/term/binding-time
5. https://www.thiengo.com.br/padrao-de-projeto-strategy-estrategia
6. https://sourcemaking.com/design_patterns/strategy
