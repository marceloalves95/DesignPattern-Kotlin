# **Design Pattern**

> *Design Patterns ou Padrões de Projetos são soluções generalistas para problemas recorrentes durante o desenvolvimento de um software. Não se trata de um framework ou um código pronto, mas de uma definição de alto nível de como um problema comum pode ser solucionado.*

Esses conceitos ficaram realmente conhecidos em 1994, quando os engenheiros de software Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides escreveram o livro **“Design Patterns: Elements of Reusable Object-Oriented Software”** com o objetivo de catalogar problemas comuns aos projetos de desenvolvimento de software e as formas de resolver esses problemas. Os autores catalogaram 23 padrões que utilizaram ao longo de suas carreiras. 

### Quais os benefícios de utilizar Design Pattern?

Design Patterns são modelos que já foram utilizados e testados anteriormente, portanto podem representar um bom **ganho de produtividade** para os desenvolvedores. Seu uso também contribui para a **organização e manutenção** de projetos, já que esses padrões se baseiam em baixo acoplamento entre as classes e padronização do código. Além disso, com a padronização dos termos, as **discussões técnicas** são **facilitadas**. É mais fácil falar o nome de um Design Pattern em vez de ter que explicar todo o seu comportamento.

Os autores do livro **“Design Patterns: Elements of Reusable Object-Oriented Software”** agruparam os Design Patterns em três tipos diferentes: Creational (Criação), Structural (Estrutura), Behavioral (Comportamental). Assim como podemos ver na tabela abaixo. 

> **Observação:** Nessa tabela também foram acrescentadas novos Design Patterns. 

| Creational Patterns | Structural Patterns |   Behavioral Patterns   |
| :-----------------: | :-----------------: | :---------------------: |
|  Abstract Factory   |       Adapter       | Chain of Responsibility |
|       Builder       |       Bridge        |         Command         |
|   Factory Method    |      Composite      |       Interpreter       |
|     Object Pool     |      Decorator      |        Iterator         |
|      Prototype      |       Facade        |        Mediator         |
|      Singleton      |      Flyweight      |       Null Object       |
|                     | Private Class Data  |        Observer         |
|                     |        Proxy        |          State          |
|                     |                     |        Strategy         |
|                     |                     |     Template Method     |
|                     |                     |         Visitor         |

## Creational Patterns

### Abstract Factory

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Builder

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Factory Method

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Object Pool

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Prototype

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Singleton

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

## Structural Patterns

### Adapter

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Bridge

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Composite

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Decorator

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Facade

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Flyweight

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Private Class Data

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Proxy

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

## Behavioral Patterns

### Chain of Responsibility

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Command

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Interpreter

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Iterator

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Mediator

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Null Object

**Definição**

> *O padrão Null Object propõe a criação de uma classe para representar objetos nulos em uma aplicação.*

**Utilização**

Essa classe deve estender a classe original e implementar seus métodos de forma a executar o comportamento esperado da aplicação quando um valor nulo for recebido. Dessa forma, em vez de se retornar um valor nulo, retorna-se uma instância dessa nova classe.

##### Diagrama de Classe

| ![](src/uml/NullObject.png) |
| :--------------------------: |

##### Classe Null Object

```kotlin
class NullObject {

    abstract class ClienteAbstrato{

        abstract fun isNulo():Boolean
        abstract fun getNome():String
    }
    class ClienteReal(private var nome:String):ClienteAbstrato(){

        override fun isNulo(): Boolean = false
        override fun getNome(): String = nome

    }
    class ClienteNulo:ClienteAbstrato(){

        override fun isNulo(): Boolean = true
        override fun getNome(): String = "Não existe esse nome na lista"

    }
    class ClienteFactory{

        companion object Fabrica{

            val listaNomes = listOf("Lucas", "João", "Maria")

            fun getCliente(nome:String):ClienteAbstrato{

                listaNomes.forEach { nomes->

                    if (nomes == nome) {
                        return ClienteReal(nome)
                    }

                }

                return ClienteNulo()

            }
        }
    }

}
```

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Observer

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### State

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Strategy

**Definição**

> *Define uma família de algoritmos, encapsular cada uma delas e as torna intercambiáveis. Esse padrão permite que o algoritmo varie independentemente dos clientes que o utilizam.*

**Utilização**

O Strategy é um padrão que deve ser utilizado quando ***uma classe possuir diversos algoritmos que possam ser utilizados de forma intercambiável***. A solução proposta pelo padrão consiste em delegar a execução do algoritmo para uma instância que compõe a classe principal. Dessa forma, quando a funcionalidade for invocada, no momento da execução do algoritmo, será invocado um método da instância que a compõe.

**Veja um exemplo:**

##### Diagrama de Classe - Strategy

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe Strategy

```kotlin
class Strategy {

    abstract class Felino(private val correrStrategy:CorrerStrategy){

        abstract fun display()
        abstract fun rugir()
        fun perfomarCorrer() = correrStrategy.correr()
        fun getCorrerStrategy(correrStrategy:CorrerStrategy) = correrStrategy.correr()

    }

    class Leao:Felino(CorrerCurtaDistancia()) {

        override fun display() = println("Leão a vista")
        override fun rugir() = println("Urghhhhh!")

    }
    class Leopardo:Felino(CorrerLongaDistancia()){

        override fun display() = println("Leopardo a vista")
        override fun rugir() = println("Arghh!")

    }
    interface CorrerStrategy{
        fun correr()
    }
    class CorrerCurtaDistancia:CorrerStrategy{
        override fun correr() = println("Correr curta distância, porém com o objetivo bem próximo.")
    }
    class CorrerLongaDistancia:CorrerStrategy{
        override fun correr() = println("Correr longa distância, caso necessário.")
    }

}
```

#### **Pontos Positivos**

- **Leitura mais eficiente:** quando usamos esse padrão em nosso projeto, ou em parte dele, isso torna o nosso *código mais legível e organizado*.
- **Reutilização de código:**  isso é bem evidente nesse padrão de projeto, sendo que as famílias de algoritmos podem ser *utilizadas por outras classes com diversos contextos diferentes*.
- **Evolução eficiente no seu projeto:** Isso é possível porque o foco aqui é a **composição**. Isso *evita que as classes e subclasses sejam alteradas caso novas funcionalidades sejam adicionadas ou atualizadas*. 

- **O algoritmo pode ser alterado sem a modificação da classe:** a partir dessa estrutura, *novas implementações dele podem ser criadas e introduzidas posteriormente*.
- **A lógica condicional na classe principal é reduzida:** como a escolha do algoritmo está na implementação do objeto que está compondo a classe, isso *elimina a necessidade de ter condicionais para selecionar a lógica a ser executada*. 
- **A implementação pode ser trocada em tempo de execução:** isso faz com que o *comportamento da classe possa ser trocado dinamicamente*. Além disso, o seu projeto se *torna mais dinâmico permitindo assim mais opções de funcionalidades*.

> **Composição (de Objetos):** em ciência da computação, composição de objetos é uma maneira de se combinar objetos simples ou tipos de dados em objetos mais complexos. Ela costuma ser usada como alternativa ao uso de **Herança**.

> **Herança:** é um mecanismo que permite que características comuns a diversas classes sejam fatoradas em uma classe base, ou superclasse. Esse importante conceito possibilita que as classes compartilhem seus atributos, métodos e outros membros da classe entre si. Para a ligação entre as classes, a herança adota um relacionamento esquematizado hierarquicamente. Na Herança temos dois tipos principais de classe:
>
> - **Classe Base**: a classe que concede as características a uma outra classe.
> - **Classe Derivada**: a classe que herda as características da classe base.

#### **Pontos Negativos**

- **Complexidade na criação do objeto:** a instância da dependência *precisa ser criada e configurada*. Caso o atributo seja nulo, *a classe pode apresentar um comportamento inesperado*. 
- **Aumento no número de classes:** há uma para cada algoritmo, criando uma *maior dificuldade em seu gerenciamento*. Isso pode ser muito ruim, se houverem muitas funcionalidades que não podem ser implementadas por classes de uma mesma família de classes Strategy.
- **Complexidade do projeto:** o projeto pode ficar mais *complexo caso uma solução com herança seja mais simples de implementar e manter*.

### Template Method

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

### Visitor

**Definição**

**Utilização**

##### Diagrama de Classe

| ![](src/uml/Strategy.png) |
| :-----------------------: |

##### Classe 

**Veja um exemplo:**

#### **Pontos Positivos**

#### **Pontos Negativos**

## Fontes

1. https://www.opus-software.com.br/design-patterns/
2. **Livro:** Design Patterns com Java - Projeto orientado a objetos guiados por padrões - Eduardo Guerra
3. https://www.thiengo.com.br/padrao-de-projeto-strategy-estrategia
4. https://sourcemaking.com/design_patterns/strategy
